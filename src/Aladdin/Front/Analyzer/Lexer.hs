module Aladdin.Front.Analyzer.Lexer where

import Aladdin.Front.Analyzer.Grammar
import Aladdin.Front.Header
import qualified Control.Monad.Trans.State.Strict as XState
import qualified Data.Functor.Identity as XIdentity
import qualified Data.Map.Strict as XMap
import qualified Data.Set as XSet


-- the following codes are generated by LGS.

data DFA
    = DFA
        { getInitialQOfDFA :: Int
        , getFinalQsOfDFA :: XMap.Map Int Int
        , getTransitionsOfDFA :: XMap.Map (Int, Char) Int
        , getMarkedQsOfDFA :: XMap.Map Int (XSet.Set Int)
        }
    deriving ()

runAladdinLexer :: String -> Either (Int, Int) [Token]
runAladdinLexer = doLexing . addLoc 1 1 where
    -- it is the state 0 that any string matches the regex "" iff it reaches from the initial state.
    -- it is the state 1 that any string matches the regex () iff it reaches from the initial state.
    -- it is the state 2 that any string matches the regex "-" iff it reaches from the initial state.
    -- it is the state 3 that any string matches the regex "." iff it reaches from the initial state.
    -- it is the state 4 that any string matches the regex "->" iff it reaches from the initial state.
    theDFA :: DFA
    theDFA = DFA
        { getInitialQOfDFA = 0
        , getFinalQsOfDFA = XMap.fromAscList [(3, 1), (4, 2)]
        , getTransitionsOfDFA = XMap.fromAscList 
            [ ((0, '-'), 2), ((0, '.'), 3)
            , ((2, '>'), 4)
            ]
        , getMarkedQsOfDFA = XMap.fromAscList []
        }
    runDFA :: DFA -> (ch -> Char) -> [ch] -> ((Maybe Int, [ch]), [ch])
    runDFA (DFA q0 qfs deltas markeds) toChar = XIdentity.runIdentity . go where
        loop1 q buffer [] = return buffer
        loop1 q buffer (ch : str) = do
            case XMap.lookup (q, toChar ch) deltas of
                Nothing -> return (buffer ++ [ch] ++ str)
                Just p -> case XMap.lookup p qfs of
                    Nothing -> loop1 p (buffer ++ [ch]) str
                    latest' -> do
                        (latest, accepted) <- XState.get
                        XState.put (latest', accepted ++ buffer ++ [ch])
                        loop1 p [] str
        loop2 qs q [] buffer = return buffer
        loop2 qs q (ch : str) buffer = do
            case XMap.lookup (q, toChar ch) deltas of
                Nothing -> return (buffer ++ [ch] ++ str)
                Just p -> case p `XSet.member` qs of
                    False -> loop2 qs p str (buffer ++ [ch])
                    True -> do
                        accepted <- XState.get
                        XState.put (accepted ++ buffer ++ [ch])
                        loop2 qs p str []
        go input = do
            (rest, (latest, accepted)) <- XState.runStateT (loop1 q0 [] input) (Nothing, [])
            case latest >>= flip XMap.lookup markeds of
                Nothing -> return ((latest, accepted), rest)
                Just qs -> do
                    (rest', accepted') <- XState.runStateT (loop2 qs q0 accepted []) []
                    return ((latest, accepted'), rest' ++ rest)
    addLoc :: Int -> Int -> String -> [((Int, Int), Char)]
    addLoc _ _ [] = []
    addLoc row col (ch : chs) = if ch == '\n' then ((row, col), ch) : addLoc (row + 1) 1 chs else ((row, col), ch) : addLoc row (col + 1) chs
    doLexing :: [((Int, Int), Char)] -> Either (Int, Int) [Token]
    doLexing [] = return []
    doLexing str0 = do
        let returnJust = return . Just
        (str1, piece) <- case runDFA theDFA snd str0 of
            ((_, []), _) -> Left (fst (head str0))
            ((Just label, accepted), rest) -> return (rest, ((label, map snd accepted), (fst (head accepted), fst (head (reverse accepted)))))
            _ -> Left (fst (head str0))
        maybe_token <- case piece of
            ((1, this), ((row1, col1), (row2, col2))) -> returnJust (T_dot (SLoc (row1, col1) (row2, col2)))
            ((2, this), ((row1, col1), (row2, col2))) -> return Nothing
        fmap (maybe id (:) maybe_token) (doLexing str1)

